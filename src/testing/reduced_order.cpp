#include <iostream>

#include "reduced_order.h"
#include "parameters/all_parameters.h"
#include "pod/proper_orthogonal_decomposition.h"
#include <fstream>

#include <deal.II/numerics/vector_tools.h>
#include <deal.II/numerics/solution_transfer.h>
#include <deal.II/base/numbers.h>
#include <deal.II/base/function_parser.h>
#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/grid_refinement.h>
#include <deal.II/grid/grid_tools.h>
#include <deal.II/grid/grid_out.h>
#include <deal.II/grid/grid_in.h>

#include "burgers_rewienski_snapshot.h"
#include "parameters/all_parameters.h"
#include "dg/dg_factory.hpp"
#include "ode_solver/ode_solver_factory.h"
#include "ode_solver/pod_galerkin_ode_solver.h"


namespace PHiLiP {
namespace Tests {

template <int dim, int nstate>
ReducedOrder<dim, nstate>::ReducedOrder(const PHiLiP::Parameters::AllParameters *const parameters_input)
        : TestsBase::TestsBase(parameters_input)
{}

template <int dim, int nstate>
int ReducedOrder<dim, nstate>::run_test() const
{
    const Parameters::AllParameters param = *(TestsBase::all_parameters);

    //User-defined number of basis functions
    int num_basis = 160;
    std::shared_ptr<ProperOrthogonalDecomposition::POD> pod= std::make_shared<ProperOrthogonalDecomposition::POD>(num_basis);

    //Read files generated by tests run from the bash script to form full pod basis (u_svd)
    pod->get_full_pod_basis();
    //Get reduced basis with num_basis columns
    pod->build_reduced_pod_basis();

    using Triangulation = dealii::Triangulation<dim>;
    std::shared_ptr<Triangulation> grid = std::make_shared<Triangulation>();

    double left = param.grid_refinement_study_param.grid_left;
    double right = param.grid_refinement_study_param.grid_right;
    const bool colorize = true;
    int n_refinements = param.grid_refinement_study_param.num_refinements;
    unsigned int poly_degree = param.grid_refinement_study_param.poly_degree;
    dealii::GridGenerator::hyper_cube(*grid, left, right, colorize);

    grid->refine_global(n_refinements);
    pcout << "Grid generated and refined" << std::endl;

    /*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
    /*POD GALERKIN SOLUTION*/

    pcout << "Running POD-Galerkin ODE solver for Burgers Rewienski with parameter a: "
          << param.reduced_order_param.rewienski_a
          << " and parameter b: "
          << param.reduced_order_param.rewienski_b
          << std::endl;

    std::shared_ptr < PHiLiP::DGBase<dim, double> > dg_pod_galerkin = PHiLiP::DGFactory<dim,double>::create_discontinuous_galerkin(all_parameters, poly_degree, grid);
    pcout << "dg pod-galerkin created" <<std::endl;
    dg_pod_galerkin->allocate_system ();

    pcout << "Implement initial conditions" << std::endl;
    dealii::FunctionParser<1> initial_condition;
    std::string variables = "x";
    std::map<std::string,double> constants;
    constants["pi"] = dealii::numbers::PI;
    std::string expression = "1";
    initial_condition.initialize(variables, expression, constants);
    dealii::VectorTools::interpolate(dg_pod_galerkin->dof_handler,initial_condition,dg_pod_galerkin->solution);

    pcout << "Create POD-Galerkin ODE solver" << std::endl;
    // Create ODE solver using the factory and providing the DG object
    Parameters::ODESolverParam::ODESolverEnum ode_solver_type = Parameters::ODESolverParam::ODESolverEnum::pod_galerkin_solver;
    std::shared_ptr<PHiLiP::ODE::ODESolverBase<dim, double>> ode_solver_galerkin = PHiLiP::ODE::ODESolverFactory<dim, double>::create_ODESolver_manual(ode_solver_type, dg_pod_galerkin, pod);

    pcout << "Advancing solution time" << std::endl;

    double finalTime = param.reduced_order_param.final_time;
    ode_solver_galerkin->advance_solution_time(finalTime);
    dealii::LinearAlgebra::distributed::Vector<double> pod_galerkin_solution(dg_pod_galerkin->solution);

    /*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
    /* FULL SOLUTION WITH IMPLICIT SOLVER */

    pcout << "Running full-order implicit ODE solver for Burgers Rewienski with parameter a: "
          << param.reduced_order_param.rewienski_a
          << " and parameter b: "
          << param.reduced_order_param.rewienski_b
          << std::endl;

    std::shared_ptr < PHiLiP::DGBase<dim, double> > dg_implicit = PHiLiP::DGFactory<dim,double>::create_discontinuous_galerkin(all_parameters, poly_degree, grid);
    pcout << "dg implicit created" <<std::endl;
    dg_implicit->allocate_system ();

    dealii::VectorTools::interpolate(dg_implicit->dof_handler,initial_condition,dg_implicit->solution);

    pcout << "Create implicit solver" << std::endl;
    // Create ODE solver using the factory and providing the DG object
    ode_solver_type = Parameters::ODESolverParam::ODESolverEnum::implicit_solver;
    std::shared_ptr<PHiLiP::ODE::ODESolverBase<dim, double>> ode_solver_implicit = PHiLiP::ODE::ODESolverFactory<dim, double>::create_ODESolver_manual(ode_solver_type, dg_implicit);

    pcout << "Advancing solution time" << std::endl;

    ode_solver_implicit->advance_solution_time(finalTime);
    dealii::LinearAlgebra::distributed::Vector<double> implicit_solution(dg_implicit->solution);

    double error = (pod_galerkin_solution.operator-=(implicit_solution)).l2_norm();

    pcout << "Error: " << error;

    if (error < 0.05){
        pcout << "Passed!";
        return 0;
    }else{
        pcout << "Failed!";
        return -1;
    }

    //delete all snapshot and solution files

}
#if PHILIP_DIM==1
        template class ReducedOrder<PHILIP_DIM,PHILIP_DIM>;
#endif
    } // Tests namespace
} // PHiLiP namespace
